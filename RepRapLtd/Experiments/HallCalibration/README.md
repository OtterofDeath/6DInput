# Calibrating Hall Sensors Automatically using a RepRap Machine

Adrian Bowyer


## The Idea

![RepRap Setup](https://github.com/RepRapLtd/6DInput/blob/main/RepRapLtd/Experiments/HallCalibration/reprap-setup.jpg)

What we wanted to know is: can we digitise 6-degree-of-freedom movement by having that movement move magnets around near Hall-effect sensors?

This experiment tested a two-dimensional version of that idea.  It did so by attaching a small magnet to the carriage of a RepRap machine and two Hall sensors to its bed, then running a Python program to drive the head about while monitoring the voltages generated by the Hall sensors.

The magnets [were these](https://www.amazon.co.uk/gp/product/B00TACH0P2), and the Hall sensors were OH49E s.

The picture above shows the arrangement - two sensors, H<sub>0</sub> and H<sub>1</sub>, were attached to the bed using Blu Tack 15 mm apart on the X axis at *x* = 5 and *x* = 20, and the magnet was attached to the carriage, again with Blu Tack.

The Python program ([which is in this repository here](https://github.com/RepRapLtd/6DInput/tree/main/RepRapLtd/Software/CalibrationMapPython)) moved the RepRap machine from *x* = 0 to *x* = 25 in steps of 1mm taking readings from the Hall sensors at each step. It then moved up in *z* by 1mm and repeated the *x* movements, to a maximum of *z* = 10.

The Hall readings were done by an Arduino Uno. The program for that is [in this repository here](https://github.com/RepRapLtd/6DInput/tree/main/RepRapLtd/Software/CalibrationMapArduino).

There is a video of the experiment in progress in this directory: running-experiment.mp4 .


## 2 Dimensional Results

The raw integer values of the Hall voltages, H<sub>0</sub> and H<sub>1</sub> logged by the Arduino were summed and differenced as in this idea from a few days ago:

![Sum Diff Idea](https://github.com/RepRapLtd/6DInput/blob/main/RepRapLtd/Ideas/hall-effect-idea.jpg)

The idea behind this was that the sum should be roughly proportional to movement in *z* (*y* on the original idea sketch) and the difference should be roughly proportional to movement in *x*.

Here are the matrices of sum and difference calibration values plotted by GNUPlot:

![Sum and Diff](https://github.com/RepRapLtd/6DInput/blob/main/RepRapLtd/Experiments/HallCalibration/sum-and-difference.png)

Remember the Hall sensors were at (5,0) and (20,0).

Then the Python program repeated the movements, but this time attempted to calculate the *x* and *z* coordinates that the magnet was at from the Hall readings by comparing the Hall sum and difference values to the two calibration matrices illustrated above. It used simple Euclidean distance in the sum/difference space to find the closest corresponding *x* and *z* values.  It got most right (zero Euclidean distance).  Here is a plot of the errors:

![errors](https://github.com/RepRapLtd/6DInput/blob/main/RepRapLtd/Experiments/HallCalibration/errors.png)

It's clear from this that we are being a bit ambitious about range. There are flat areas in the sum and difference maps that will lead to uncertainty about the position of the magnet in space. So we repeated the experiment with the hall sensors 10 mm apart and with a *z* range of 5mm. Here is the error map:

![small errors](https://github.com/RepRapLtd/6DInput/blob/main/RepRapLtd/Experiments/HallCalibration/small-errors.png)

The Hall sensors were at (2.5, 0) and (12.5, 0). As you can see the positioning was perfect in between the two sensors, with zero error, and there were small errors just outside the range.

## 3 Dimensional Results

![RepRap 3D Setup](https://github.com/RepRapLtd/6DInput/blob/main/RepRapLtd/Experiments/HallCalibration/reprap-3D-setup.jpg)

The next experiment was to attempt to find the position of the magnet in a three-dimensional (*x, y, z*) volume, as opposed to a two-dimensional (*x, z*) plane. For this we attached a ring of three Hall sensors to the RepRap's bed at 120<sup>o</sup> as shown above. The centres of the sensors were on a circle of radius 6mm. The magnet was attached to the carriage as before using a lump of Blu Tack.

Once again the RepRap drove the magnet about above the sensors logging the three Hall voltages at each step. This time it moved in a rectangular box 14x14x7 mm in size in 1mm steps in each direction, which is to say a box that contained a 7mm radius cylinder of height 7mm - slightly outside the circle of centres of the sensors.  Readings were only taken within the cylinder.

The system then repeated the movements, attempting to deduce the position of the RepRap carriage from the Hall readings as before.  No sums and differences were used for this; we just used the raw Hall voltages digitised by the Arduino's analog to digital converters to lie in the range [0, 1023]. Here are eight plots of the errors at each height.

![Sum and Diff](https://github.com/RepRapLtd/6DInput/blob/main/RepRapLtd/Experiments/HallCalibration/errors3D-small.png)

*Notes:*

- The -1.0 values are not errors; those are just the points outside the cylinder of measured positions.
- The error values are in mm: the error in (*x, y, z*) position.
- The vertical error scales are not the same in each plot; they span the maximum and minimum at each *z* value.
- There are very few errors **inside** the disc of the sensors.
- There is zero error everywhere at *z* = 3mm.




